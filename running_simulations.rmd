```{r, loading_libs_compiling_model}
library(dplyr)
library(rstan)
library(stringr)
library(rio)
library(gridExtra)
options(scipen=999)

source('utils.r')
model <- stan_model('neg_binomial_partial_pooling.stan')
```

```{r, generate_group_sizes}
set.seed(2)

w <- c(20, 20, 20, 20, 0.1, 0.1)
mu.rho <- c(2.5, 3.5, 4.5, 5, 5.5, 6.5)
num.subpopulations <- length(mu.rho)
sigma.rho <- rep(1, num.subpopulations)

shape.rho <- (mu.rho**2) / (sigma.rho **2)
rate.rho <- (mu.rho) / (sigma.rho **2)

num.regions <- 150
rho_j <- matrix(0, ncol=num.subpopulations, nrow=num.regions)
for(region in 1:num.regions){
  rho_j[region,]  <- -rgamma(num.subpopulations, shape=shape.rho, rate=rate.rho)                                 
}

all.p.k <- rho_j %>% exp() 
colnames(all.p.k) <- paste0('subpopulation_', 1:num.subpopulations)
all.p.k %>% head(20)

known.group.indices <- c(1, 2, 3, 4)
unknown.group.indices <- setdiff(1:num.subpopulations, known.group.indices)
sim.num.respondents <- c(5, 10, 15, 20, 30, 50, 100, 200)
population <- 1000000
```


```{r, running_one_set_of_regions}
num.regions <- 150
num.respondents <- 50

set.seed(71)

spatial.results <- matrix(0, ncol=3) %>% as.data.frame()
full.spatial.results <- matrix(0, ncol=3) %>% as.data.frame()

colnames(spatial.results) <- c('num_respondents', 'mean_error', 'model')
colnames(full.spatial.results) <- c('num_respondents', 'mean_error', 'model')

cat(paste('Currently simulating with', num.respondents, 'respondents'), '\n')

ard <- matrix(0, ncol=num.subpopulations)
for(region in 1:num.regions){
  # Generate NB data for multiple regions and estimate the prevalence
  # using the NB model and correlated scaling
  p.k <- as.numeric(all.p.k[region, ])
  nb.ard <- generate.uncorr.nb.ard(num.respondents = num.respondents,
                            num.subpopulations = length(mu.rho),
                            total.pop.size = population,
                            p.k = p.k,
                            w)   
  ard <- rbind(ard, nb.ard)
}
ard <- ard[-1,]

data <- list(N = nrow(ard),
              K = ncol(ard),
              y = ard,
              # offset = rep(population, nrow(ard)),
              J = num.regions, 
              jj = rep(1:num.regions, each=num.respondents))

fit <- sampling(model, data = data, warmup=750,
        iter = 2000, cores=20,
        chains = 2, seed=920, verbose=F, show_messages=F)

parameter.names <- dimnames(fit)$parameters

params <- extract(fit)
rho_j <- params$rho_j
# correlation <- compute.correlation.samples(params)

mean.abs.relative.error <- 0
for(region in 1:num.regions){
  true.p.k <- all.p.k[region,]
  rho <- rho_j[,region,] * -1
  nb.estimate <- posteriorRhoScaling(rho, 
                    population*all.p.k[region, known.group.indices], 
                    population)               
  mean.estimate <- colMeans(nb.estimate, na.rm=T) %>% pmin(0)                  

  region.error  <- mean(abs((exp(mean.estimate[-known.group.indices]) - true.p.k[-known.group.indices])) 
    / true.p.k[-known.group.indices])

  mean.abs.relative.error <- mean.abs.relative.error + region.error

  full.spatial.results <- rbind(full.spatial.results, 
                            c(num.respondents, 
                              region.error,
                              'negative_binomial'))
}

spatial.results <- rbind(spatial.results, 
                            c(num.respondents, 
                              mean.abs.relative.error/num.regions,
                              'negative_binomial')) 

mean.abs.relative.error <- 0
for(region in 1:num.regions){
  p.k <- as.numeric(all.p.k[region, ])
  res <- c(1:num.respondents + (region-1)*num.respondents)
  binomial.estimate <- killworth(ard[res, ], 
              known.group.indices=known.group.indices, 
              known.group.sizes=p.k[known.group.indices]*population,
              total.pop.size=population)

  region.error  <- mean(abs((binomial.estimate - p.k[-known.group.indices])/ p.k[-known.group.indices]))
  mean.abs.relative.error <- mean.abs.relative.error + region.error

  full.spatial.results <- rbind(full.spatial.results, 
                          c(num.respondents, 
                            region.error,
                            'binomial'))
}
spatial.results <- rbind(spatial.results, 
                        c(num.respondents, 
                          mean.abs.relative.error/num.regions,
                          'binomial'))  

parameter.names <- dimnames(fit)$parameters
full.spatial.results <- full.spatial.results[-1,] %>% mutate_at(vars(-model), as.numeric)
spatial.results <- spatial.results[-1,] %>% mutate_at(vars(-model), as.numeric)

display.simulated.rho_j(83, all.p.k, fit)
```


```{r, running_multiple_sets_of_regions}
set.seed(71)
num.regions <- 150

spatial.results <- matrix(0, ncol=3) %>% as.data.frame()
full.spatial.results <- matrix(0, ncol=3) %>% as.data.frame()

colnames(spatial.results) <- c('num_respondents', 'mean_error', 'model')
colnames(full.spatial.results) <- c('num_respondents', 'mean_error', 'model')

for(num.respondents in sim.num.respondents){
  cat(paste('Currently simulating with', num.respondents, 'respondents'), '\n')
  # Generate NB data for multiple regions and estimate the prevalence
  # using the NB model and correlated scaling
  ard <- matrix(0, ncol=num.subpopulations)

  for(region in 1:num.regions){
    p.k <- as.numeric(all.p.k[region, ])
    nb.ard <- generate.uncorr.nb.ard(num.respondents = num.respondents,
                              num.subpopulations = length(mu.rho),
                              total.pop.size = population,
                              p.k = p.k,
                              w = w)   
    ard <- rbind(ard, nb.ard)
  }
  ard <- ard[-1,]


  data <- list(N = nrow(ard),
               K = ncol(ard),
               y = ard,
               offset = rep(population, nrow(ard)),
               J = num.regions, 
               jj = rep(1:num.regions, each=num.respondents))

  fit <- sampling(model, data = data, warmup=750,
          iter = 2000, cores=20,
          chains = 2, seed=920, verbose=F, show_messages=F)

  params <- extract(fit)
  rho_j <- params$rho_j

  mean.abs.relative.error <- 0
  for(region in 1:num.regions){
    true.p.k <- all.p.k[region,]
    rho <- rho_j[,region,] * -1
    nb.estimate <- posteriorRhoScaling(rho, 
                      population*all.p.k[region, known.group.indices], 
                      population)               
    mean.estimate <- colMeans(nb.estimate, na.rm=T) %>% pmin(0)                  

    region.error  <- mean(abs((exp(mean.estimate[-known.group.indices]) - true.p.k[-known.group.indices])) 
      / true.p.k[-known.group.indices])
    mean.abs.relative.error <- mean.abs.relative.error + region.error
    
    full.spatial.results <- rbind(full.spatial.results, 
                            c(num.respondents, 
                              region.error,
                              'negative_binomial'))
  }
  spatial.results <- rbind(spatial.results, 
                            c(num.respondents, 
                              mean.abs.relative.error/num.regions,
                              'negative_binomial'))


  mean.abs.relative.error <- 0
  for(region in 1:num.regions){
    p.k <- as.numeric(all.p.k[region, ])
    res <- c(1:num.respondents + (region-1)*num.respondents)
    binomial.estimate <- killworth(ard[res, ], 
                known.group.indices=known.group.indices, 
                known.group.sizes=p.k[known.group.indices]*population,
                total.pop.size=population)

    region.error  <- mean(abs((binomial.estimate - p.k[-known.group.indices])/ p.k[-known.group.indices]))
    mean.abs.relative.error <- mean.abs.relative.error + region.error

    full.spatial.results <- rbind(full.spatial.results, 
                            c(num.respondents, 
                              region.error,
                              'binomial'))
  }
  spatial.results <- rbind(spatial.results, 
                         c(num.respondents, 
                           mean.abs.relative.error/num.regions,
                           'binomial'))                                  
}

parameter.names <- dimnames(fit)$parameters
full.spatial.results <- full.spatial.results[-1,] %>% mutate_at(vars(-model), as.numeric)
spatial.results <- spatial.results[-1,] %>% mutate_at(vars(-model), as.numeric)

display.simulated.rho_j(1, all.p.k, fit)
```


```{r, error_contributions}
display.error.contributions(all.p.k, num.regions, correlation, known.group.indices, population)
display.simulated.rho_j(8, all.p.k, fit)

for(region in 1:num.regions){
  display.simulated.rho_j(region, all.p.k, fit)
  Sys.sleep(10)
}
```


```{r, separate_data}
set.seed(5762)
for(num.respondents in sim.num.respondents){
  cat(paste('Currently simulating with', num.respondents, 'respondents'), '\n')
  # Generate NB data for multiple regions and estimate the prevalence
  # using the NB model and correlated scaling
  ard <- matrix(0, ncol=num.subpopulations)

  for(region in 1:num.regions){
    p.k <- as.numeric(all.p.k[region, ])
    nb.ard <- generate.uncorr.nb.ard(num.respondents = num.respondents,
                              num.subpopulations = length(mu.rho),
                              total.pop.size = population,
                              p.k = p.k, 
                              w = w) 
    ard <- rbind(ard, nb.ard)
  }
  ard <- ard[-1,]


  data <- list(N = nrow(ard),
               K = ncol(ard),
               y = ard,
               offset = rep(population, nrow(ard)),
               J = num.regions, 
               jj = rep(1:num.regions, each=num.respondents))

  fit <- sampling(model, data = data,
          iter = 4000, cores=20,
          chains = 2, seed=73, verbose=F, show_messages=F)

  params <- extract(fit)
  rho_j <- params$rho_j
  correlation <- compute.correlation.samples(params)

  mean.abs.relative.error <- 0
  for(region in 1:num.regions){
    true.p.k <- all.p.k[region,]
    rho <- rho_j[,region,] * -1
    nb.estimate <- posteriorRhoScaling(rho, 
                      population*all.p.k[region, known.group.indices], 
                      population)               
    mean.estimate <- colMeans(nb.estimate, na.rm=T) %>% pmin(0)                  

    mean.abs.relative.error <- mean.abs.relative.error + 
      mean(abs((exp(mean.estimate[-known.group.indices]) - true.p.k[-known.group.indices]) / true.p.k[-known.group.indices]))
  }
  spatial.results <- rbind(spatial.results, 
                            c(num.respondents, 
                              mean.abs.relative.error/num.regions,
                              'negative_binomial'))

  # Generate binomial data for multiple regions and estimate the prevalence
  # using the binomial model and the original NSUM estimator
  ard <- matrix(0, ncol=num.subpopulations)
  for(region in 1:num.regions){
    p.k <- as.numeric(all.p.k[region,] )
    binomial.ard <- generate.binomial.ard(num.respondents = num.respondents,
                num.subpopulations = length(mu.rho),
                total.pop.size = population,
                p.k = p.k)   
    ard <- rbind(ard, binomial.ard)
  }
  ard <- ard[-1,]

  mean.abs.relative.error <- 0
  for(region in 1:num.regions){
    p.k <- as.numeric(all.p.k[region, ])
    res <- c(1:num.respondents + (region-1)*num.respondents)
    binomial.estimate <- killworth(ard[res, ], 
                known.group.indices=c(1,2,3), 
                known.group.sizes=p.k[known.group.indices]*population,
                total.pop.size=population)

    mean.abs.relative.error <- mean.abs.relative.error + mean(abs((binomial.estimate - p.k[-known.group.indices])/ p.k[-known.group.indices]))

  }
  spatial.results <- rbind(spatial.results, 
                         c(num.respondents, 
                           mean.abs.relative.error/num.regions,
                           'binomial'))                                  
}
spatial.results <- spatial.results[-1,] %>% mutate_at(vars(-model), as.numeric)
```

