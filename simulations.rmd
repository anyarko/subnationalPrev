```{r, loading_libs_compiling_model}
library(dplyr)
library(rstan)
library(ggplot2)
library(stringr)
library(rio)
library(gridExtra)
options(scipen=999)

source('utils.r')
model <- stan_model('inst/stan/simple_model.stan')
```

```{r, generate_group_sizes}
set.seed(2)
# display.min.max.probs.gamma(mu=4.4, sigma=1)

w <- c(20, 20, 20, 20, 0.1, 0.1)
mu.rho <- c(2.5, 3.5, 4.5, 5, 5.5, 6.5)
num.subpopulations <- length(mu.rho)
sigma.rho <- rep(1, num.subpopulations)

shape.rho <- (mu.rho**2) / (sigma.rho **2)
rate.rho <- (mu.rho) / (sigma.rho **2)

num.regions <- 150
rho_j <- matrix(0, ncol=num.subpopulations, nrow=num.regions)
for(region in 1:num.regions){
  rho_j[region,]  <- -rgamma(num.subpopulations, shape=shape.rho, rate=rate.rho)                                 
}

all.p.k <- rho_j %>% exp() 
colnames(all.p.k) <- paste0('subpopulation_', 1:num.subpopulations)
all.p.k %>% head(20)

known.group.indices <- c(1, 2, 3, 4)
unknown.group.indices <- setdiff(1:num.subpopulations, known.group.indices)
sim.num.respondents <- c(5, 10, 15, 20, 30, 50, 100, 200)
population <- 1000000
```


```{r, one_set_of_regions}
num.regions <- 150
num.respondents <- 50

set.seed(71)

spatial.results <- matrix(0, ncol=3) %>% as.data.frame()
full.spatial.results <- matrix(0, ncol=3) %>% as.data.frame()

colnames(spatial.results) <- c('num_respondents', 'mean_error', 'model')
colnames(full.spatial.results) <- c('num_respondents', 'mean_error', 'model')

cat(paste('Currently simulating with', num.respondents, 'respondents'), '\n')

ard <- matrix(0, ncol=num.subpopulations)
for(region in 1:num.regions){
  # Generate NB data for multiple regions and estimate the prevalence
  # using the NB model and correlated scaling
  p.k <- as.numeric(all.p.k[region, ])
  nb.ard <- generate.nb.ard(num.respondents = num.respondents,
                            num.subpopulations = length(mu.rho),
                            total.pop.size = population,
                            p.k = p.k,
                            w)   
  ard <- rbind(ard, nb.ard)
}
ard <- ard[-1,]

data <- list(N = nrow(ard),
              K = ncol(ard),
              y = ard,
              # offset = rep(population, nrow(ard)),
              J = num.regions, 
              jj = rep(1:num.regions, each=num.respondents))

fit <- sampling(model, data = data, warmup=750,
        iter = 2000, cores=20,
        chains = 2, seed=920, verbose=F, show_messages=F)

parameter.names <- dimnames(fit)$parameters

params <- extract(fit)
rho_j <- params$rho_j
correlation <- compute.correlation.samples(params)

mean.abs.relative.error <- 0
for(region in 1:num.regions){
  true.p.k <- all.p.k[region,]
  rho <- rho_j[,region,] * -1
  nb.estimate <- correlatedScaling(rho, 
                    correlation, 
                    population*all.p.k[region, known.group.indices], 
                    population)               
  mean.estimate <- colMeans(nb.estimate, na.rm=T) %>% pmin(0)                  

  region.error  <- mean(abs((exp(mean.estimate[-known.group.indices]) - true.p.k[-known.group.indices])) 
    / true.p.k[-known.group.indices])

  mean.abs.relative.error <- mean.abs.relative.error + region.error

  full.spatial.results <- rbind(full.spatial.results, 
                            c(num.respondents, 
                              region.error,
                              'negative_binomial'))
}

spatial.results <- rbind(spatial.results, 
                            c(num.respondents, 
                              mean.abs.relative.error/num.regions,
                              'negative_binomial')) 

mean.abs.relative.error <- 0
for(region in 1:num.regions){
  p.k <- as.numeric(all.p.k[region, ])
  res <- c(1:num.respondents + (region-1)*num.respondents)
  binomial.estimate <- killworth(ard[res, ], 
              known.group.indices=known.group.indices, 
              known.group.sizes=p.k[known.group.indices]*population,
              total.pop.size=population)

  region.error  <- mean(abs((binomial.estimate - p.k[-known.group.indices])/ p.k[-known.group.indices]))
  mean.abs.relative.error <- mean.abs.relative.error + region.error

  full.spatial.results <- rbind(full.spatial.results, 
                          c(num.respondents, 
                            region.error,
                            'binomial'))
}
spatial.results <- rbind(spatial.results, 
                        c(num.respondents, 
                          mean.abs.relative.error/num.regions,
                          'binomial'))  

parameter.names <- dimnames(fit)$parameters
full.spatial.results <- full.spatial.results[-1,] %>% mutate_at(vars(-model), as.numeric)
spatial.results <- spatial.results[-1,] %>% mutate_at(vars(-model), as.numeric)

display.simulated.rho_j(83, all.p.k, fit)
```


```{r, convergence_checks_one_set_of_regions}
parameter.names <- dimnames(fit)$parameters
pars <- parameter.names[grepl('mu_rho', parameter.names)]
print(fit, pars=pars)
traceplot(fit, inc_warmup = F, pars = pars) 

pars <- parameter.names[grepl('^sigma_rho', parameter.names)]
print(fit, pars=pars)
traceplot(fit, inc_warmup = F, pars = pars)


pars <- parameter.names[grepl('^tau_n', parameter.names)]
print(fit, pars=pars)
traceplot(fit, inc_warmup = F, pars = pars)

pars <- parameter.names[grepl('^rho_j\\[83,', parameter.names) ]
print(fit, pars=pars)
all.p.k[83,] %>% log()
traceplot(fit, inc_warmup = F, pars = pars)

correlation <- compute.correlation.samples(params)
apply(correlation, c(2,3), mean)


pars <- c('rho_j[83,5]', 'rho_j[83,6]')
print(fit, pars=pars)
traceplot(fit, inc_warmup = F, pars = pars)

pars <- c('mu_rho[1]', 'mu_rho[3]', 'sigma_rho[2]', 'rho_j[1,5]')
print(fit, pars=pars)
mu.sigma.j.rho.plot <- traceplot(fit, inc_warmup = F, pars = pars, nrow=1) + theme_bw()
# ggsave('visualisations/traceplot_mu_sigma_j_rho.pdf', 
#        plot= mu.sigma.j.rho.plot, width=9, height=5, units='in')


# library(gridExtra)
# pars <- parameter.names[grepl('^shape_delta', parameter.names)]
# print(fit, pars=pars)
# shape_plot <- traceplot(fit, inc_warmup = F, pars = pars) + theme_bw()

# pars <- parameter.names[grepl('^scale_delta', parameter.names)]
# print(fit, pars=pars)
# scale_plot <- traceplot(fit, inc_warmup = F, pars = pars) + theme_bw()
# shape_scale_plot <- grid.arrange(shape_plot, scale_plot, ncol=1)

# ggsave('visualisations/traceplot_shape_scale_delta_cauchy.pdf', 
#        plot= shape_scale_plot, width=6, height=5, units='in')
```


```{r, multiple_sets_of_regions}
set.seed(71)
num.regions <- 150

spatial.results <- matrix(0, ncol=3) %>% as.data.frame()
full.spatial.results <- matrix(0, ncol=3) %>% as.data.frame()

colnames(spatial.results) <- c('num_respondents', 'mean_error', 'model')
colnames(full.spatial.results) <- c('num_respondents', 'mean_error', 'model')

for(num.respondents in sim.num.respondents){
  cat(paste('Currently simulating with', num.respondents, 'respondents'), '\n')
  # Generate NB data for multiple regions and estimate the prevalence
  # using the NB model and correlated scaling
  ard <- matrix(0, ncol=num.subpopulations)

  for(region in 1:num.regions){
    p.k <- as.numeric(all.p.k[region, ])
    nb.ard <- generate.nb.ard(num.respondents = num.respondents,
                              num.subpopulations = length(mu.rho),
                              total.pop.size = population,
                              p.k = p.k)   
    ard <- rbind(ard, nb.ard)
  }
  ard <- ard[-1,]


  data <- list(N = nrow(ard),
               K = ncol(ard),
               y = ard,
               offset = rep(population, nrow(ard)),
               J = num.regions, 
               jj = rep(1:num.regions, each=num.respondents))

  fit <- sampling(model, data = data, warmup=750,
          iter = 2000, cores=20,
          chains = 2, seed=920, verbose=F, show_messages=F)

  params <- extract(fit)
  rho_j <- params$rho_j
  correlation <- compute.correlation.samples(params)

  mean.abs.relative.error <- 0
  for(region in 1:num.regions){
    true.p.k <- all.p.k[region,]
    rho <- rho_j[,region,] * -1
    nb.estimate <- correlatedScaling(rho, 
                      correlation, 
                      population*all.p.k[region, known.group.indices], 
                      population)               
    mean.estimate <- colMeans(nb.estimate, na.rm=T) %>% pmin(0)                  

    region.error  <- mean(abs((exp(mean.estimate[-known.group.indices]) - true.p.k[-known.group.indices])) 
      / true.p.k[-known.group.indices])
    mean.abs.relative.error <- mean.abs.relative.error + region.error
    
    full.spatial.results <- rbind(full.spatial.results, 
                            c(num.respondents, 
                              region.error,
                              'negative_binomial'))
  }
  spatial.results <- rbind(spatial.results, 
                            c(num.respondents, 
                              mean.abs.relative.error/num.regions,
                              'negative_binomial'))


  mean.abs.relative.error <- 0
  for(region in 1:num.regions){
    p.k <- as.numeric(all.p.k[region, ])
    res <- c(1:num.respondents + (region-1)*num.respondents)
    binomial.estimate <- killworth(ard[res, ], 
                known.group.indices=known.group.indices, 
                known.group.sizes=p.k[known.group.indices]*population,
                total.pop.size=population)

    region.error  <- mean(abs((binomial.estimate - p.k[-known.group.indices])/ p.k[-known.group.indices]))
    mean.abs.relative.error <- mean.abs.relative.error + region.error

    full.spatial.results <- rbind(full.spatial.results, 
                            c(num.respondents, 
                              region.error,
                              'binomial'))
  }
  spatial.results <- rbind(spatial.results, 
                         c(num.respondents, 
                           mean.abs.relative.error/num.regions,
                           'binomial'))                                  
}

parameter.names <- dimnames(fit)$parameters
full.spatial.results <- full.spatial.results[-1,] %>% mutate_at(vars(-model), as.numeric)
spatial.results <- spatial.results[-1,] %>% mutate_at(vars(-model), as.numeric)

display.simulated.rho_j(1, all.p.k, fit)
```


```{r, error_contributions}
display.error.contributions(all.p.k, num.regions, correlation, known.group.indices, population)
display.simulated.rho_j(8, all.p.k, fit)

for(region in 1:num.regions){
  display.simulated.rho_j(region, all.p.k, fit)
  Sys.sleep(10)
}
```


```{r, visualising_saved_results}
narrow.degree.prior <- import('results/mu_rho_2.5_6.5_seeds_427_41.csv')
narrow.degree.prior %>% 
group_by(model, num_respondents) %>% 
summarise(mean(mean_error)) #%>% 
filter(model=='negative_binomial')

wide.degree.prior <- import('results/mu_rho_2.5_6.5_seeds_2_71_920_delta_a_b_cauchy.csv')
wide.degree.prior %>%
group_by(model, num_respondents) %>%
summarise(mean(mean_error)) #%>%
filter(model=='negative_binomial')

narrow.boxplot <- narrow.degree.prior %>% 
ggplot(aes(x=as.factor(num_respondents), y=mean_error, 
           color=sub('_', ' ', model) %>% str_to_title())) +
geom_boxplot() +
labs(x='Number of respondents', 
     y='Mean Absolute Relative Error',
     color='Model') +
expand_limits(x=0, y=0) +
scale_y_continuous(breaks = seq(0, 2, length.out=9), 
                   limits=c(0, 2)) +
geom_hline(yintercept=0, linetype='dashed', color='red') +
theme_bw() +
theme(legend.position = 'bottom') 

narrow.scatter <- narrow.degree.prior %>%
group_by(model, num_respondents) %>%
summarise(mean_error = mean(mean_error)) %>%
ggplot(aes(x=num_respondents, y=mean_error, 
           color=sub('_', ' ', model) %>% str_to_title())) +
geom_point(size=3) +
labs(x='Number of respondents per region', 
     y='Mean Absolute Relative Error',
     color='Model') +
expand_limits(x=0, y=0) +   
scale_y_continuous(breaks = seq(0, 1.5, length.out=7), limits=c(0, 1.5)) +
scale_x_continuous(limits = c(0, 100)) +
geom_hline(yintercept=0, linetype='dashed', color='red') +
theme_bw() +
theme(legend.position = 'bottom')

narrow.boxplot.scatter <- grid.arrange(narrow.boxplot, 
                  narrow.scatter, ncol=2, widths=c(10,8))

# ggsave('visualisations/narrow_degree_prior_boxplot_scatter.pdf', 
#        plot= narrow.boxplot.scatter, width=9, height=5, units='in')                  
```


```{r, combining_saved_results_multiple_seeds}
folder.name <- 'results/old_tau/scott/'
folder.name <- 'results/without_theta/'
errors.file.names <- list.files(folder.name, pattern='^seeds')
all.spatial.results <- matrix(0, ncol=4) %>% as.data.frame()
colnames(all.spatial.results) <- c('num_respondents', 'mean_error', 'model', 'seed')

for(file in errors.file.names){
  spatial.results <- import(paste(folder.name, file, sep=''))
  spatial.results$seed <- as.numeric(str_extract(file, '\\d+'))
  print(as.numeric(str_extract(file, '\\d+')))
  all.spatial.results <- rbind(all.spatial.results, spatial.results)
}

all.spatial.results <- all.spatial.results[-1,] %>% mutate_at(vars(-model, -seed), as.numeric)
all.spatial.results %>% str
```


```{r, visualising_combined_results_multiple_seeds}
mean.errors <- all.spatial.results %>% group_by(seed, model, num_respondents) %>% 
summarise(mean_error = mean(mean_error)) 

mean.errors %>% 
ggplot(aes(x=num_respondents, y=mean_error, 
           color=sub('_', ' ', model) %>% str_to_title())) +
geom_point(size=3) +
labs(x='Number of respondents', 
     y='Mean Absolute Relative Error',
     color='Model') +
expand_limits(x=0, y=0) +   
scale_y_continuous(breaks = seq(0, 1.5, length.out=7), limits=c(0, 1.5)) +
geom_hline(yintercept=0, linetype='dashed', color='red') +
theme_bw() +
theme(legend.position = 'bottom')

all.spatial.results %>% group_by(seed, model, num_respondents) %>%
ggplot(aes(x=as.factor(num_respondents), y=mean_error, 
           color=sub('_', ' ', model) %>% str_to_title())) +
geom_boxplot() +
labs(x='Number of respondents', 
     y='Mean Absolute Relative Error',
     color='Model') +
expand_limits(x=0, y=0) +
scale_y_continuous(breaks = seq(0, 2, length.out=9), 
                   limits=c(0, 2)) +
geom_hline(yintercept=0, linetype='dashed', color='red') +
theme_bw() +
theme(legend.position = 'bottom')
```


```{r, visualising_both_estimators_different_respondents_same_data}
spatial.results %>% filter(model=='negative_binomial')
spatial.results %>% 
ggplot(aes(x=num_respondents, y=mean_error, 
           color=sub('_', ' ', model) %>% str_to_title())) +
geom_point(size=3) +
labs(x='Number of respondents', 
     y='Mean Absolute Relative Error',
     color='Model') +
expand_limits(x=0, y=0) +   
scale_y_continuous(breaks = seq(0, 1.5, length.out=7), limits=c(0, 1.5)) +
geom_hline(yintercept=0, linetype='dashed', color='red') +
theme_bw() +
theme(legend.position = 'bottom')

full.

spatial.results %>% group_by(model, num_respondents) %>% 
summarise(mean_error = mean(mean_error))



ggplot(aes(x=as.factor(num_respondents), y=mean_error, 
           color=sub('_', ' ', model) %>% str_to_title())) +
geom_boxplot() +
labs(x='Number of respondents', 
     y='Mean Absolute Relative Error',
     color='Model') +
expand_limits(x=0, y=0) +
scale_y_continuous(breaks = seq(0, 2, length.out=9), 
                   limits=c(0, 2)) +
geom_hline(yintercept=0, linetype='dashed', color='red') +
theme_bw() +
theme(legend.position = 'bottom') 

# write.csv(full.spatial.results, 'results/mu_rho_2.5_6.5_seeds.csv', row.names=F)
# ggsave('visualisations/boxplot_mu_rho_2.5_6.5_seeds_427_41.pdf', width=7, height=8, units='in')
# ggsave('visualisations/scatter_mu_rho_2.5_6.5_seeds_427_41.pdf', width=6, height=5, units='in')
```



```{r, separate_data}
set.seed(5762)
for(num.respondents in sim.num.respondents){
  cat(paste('Currently simulating with', num.respondents, 'respondents'), '\n')
  # Generate NB data for multiple regions and estimate the prevalence
  # using the NB model and correlated scaling
  ard <- matrix(0, ncol=num.subpopulations)

  for(region in 1:num.regions){
    p.k <- as.numeric(all.p.k[region, ])
    nb.ard <- generate.nb.ard(num.respondents = num.respondents,
                              num.subpopulations = length(mu.rho),
                              total.pop.size = population,
                              p.k = p.k)   
    ard <- rbind(ard, nb.ard)
  }
  ard <- ard[-1,]


  data <- list(N = nrow(ard),
               K = ncol(ard),
               y = ard,
               offset = rep(population, nrow(ard)),
               J = num.regions, 
               jj = rep(1:num.regions, each=num.respondents))

  fit <- sampling(model, data = data,
          iter = 4000, cores=20,
          chains = 2, seed=73, verbose=F, show_messages=F)

  params <- extract(fit)
  rho_j <- params$rho_j
  correlation <- compute.correlation.samples(params)

  mean.abs.relative.error <- 0
  for(region in 1:num.regions){
    true.p.k <- all.p.k[region,]
    rho <- rho_j[,region,] * -1
    nb.estimate <- correlatedScaling(rho, 
                      correlation, 
                      population*all.p.k[region, known.group.indices], 
                      population)               
    mean.estimate <- colMeans(nb.estimate, na.rm=T) %>% pmin(0)                  

    mean.abs.relative.error <- mean.abs.relative.error + 
      mean(abs((exp(mean.estimate[-known.group.indices]) - true.p.k[-known.group.indices]) / true.p.k[-known.group.indices]))
  }
  spatial.results <- rbind(spatial.results, 
                            c(num.respondents, 
                              mean.abs.relative.error/num.regions,
                              'negative_binomial'))

  # Generate binomial data for multiple regions and estimate the prevalence
  # using the binomial model and the original NSUM estimator
  ard <- matrix(0, ncol=num.subpopulations)
  for(region in 1:num.regions){
    p.k <- as.numeric(all.p.k[region,] )
    binomial.ard <- generate.binomial.ard(num.respondents = num.respondents,
                num.subpopulations = length(mu.rho),
                total.pop.size = population,
                p.k = p.k)   
    ard <- rbind(ard, binomial.ard)
  }
  ard <- ard[-1,]

  mean.abs.relative.error <- 0
  for(region in 1:num.regions){
    p.k <- as.numeric(all.p.k[region, ])
    res <- c(1:num.respondents + (region-1)*num.respondents)
    binomial.estimate <- killworth(ard[res, ], 
                known.group.indices=c(1,2,3), 
                known.group.sizes=p.k[known.group.indices]*population,
                total.pop.size=population)

    mean.abs.relative.error <- mean.abs.relative.error + mean(abs((binomial.estimate - p.k[-known.group.indices])/ p.k[-known.group.indices]))

  }
  spatial.results <- rbind(spatial.results, 
                         c(num.respondents, 
                           mean.abs.relative.error/num.regions,
                           'binomial'))                                  
}
spatial.results <- spatial.results[-1,] %>% mutate_at(vars(-model), as.numeric)
```


```{r}
spatial.results %>% filter(model=='negative_binomial') %>% head
spatial.results %>% 
ggplot(aes(x=num_respondents, y=mean_error, color=model)) +
geom_point(size=3) +
labs(x='Number of respondents', 
     y='Mean Absolute Relative Error') +
expand_limits(x=0, y=0) +   
ylim(0, 1.5) +
geom_hline(yintercept=0, linetype='dashed', color='red') +
theme_bw() 

# ggsave('visualisations/same_data_mean_abs_rel_error_cauchy_priors_150_regions.pdf', width=6, height=5, units='in')
```


```{r}
parameter.names <- dimnames(fit)$parameters
pars <- parameter.names[grepl('^rho_j\\[140,', parameter.names) ]

# pars <- parameter.names[grepl('^rate_rho', parameter.names) ]
# pars
print(fit, pars=pars)
# traceplot(fit, inc_warmup = TRUE, pars = pars)

all.p.k[140,] %>% log()

for(region in 1:num.regions){
  pars <- parameter.names[grepl(paste0('^rho_j\\[', region), parameter.names) ]
  print(fit, pars=pars)
  print(paste('True prevalence for region', region, 'is', all.p.k[region,] %>% log()))
}
```
